## 索引

### 索引的分类

#### 按物理存储分类
1. 主键索引  
    B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里
2. 二级索引  
   二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据

#### 按字段特性分类
1. 主键索引：primary key 索引列的值不允许有空值
2. 唯一索引：unique key 索引列的值必须唯一，允许有空值
3. 普通索引：index 
4. 前缀索引：对字符类型字段的前几个字符建立的索引，以减少索引所占用的存储空间，提升查询效率

#### 按字段个数分类
1. 单列索引：例如主键索引
2. 联合索引：将多个字段组合成一个索引，存在最左匹配原则
   - 联合索引范围查询
      - 遇到范围查询> <会停止匹配
      - 但是对于>=, <=, BETWEEN, like前缀匹配的范围查询时，还会继续匹配
   - 索引下推：在联合索引遍历的过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。
   - 索引区分度：建立联合索引时，要把区分度大的字段排在前面，例如性别的区分度很小，不适合建立联合索引或者排在联合索引列靠前的位置
   - 联合索引进行排序：`select * from order where status = 1 order by create_time asc`,更好的方式是给status和create_time建一个
   联合索引，利用索引的有序性，避免MySQl数据库发生文件排序

### 索引优化方法
#### 前缀索引优化
- 使用前缀索引可以减小索引的查询速度，例如大字符串作为索引时，可以考虑使用前缀索引
- 局限性：
  - order by无法使用前缀索引
  - 无法把前缀索引作覆盖索引

#### 覆盖索引优化
对于所需要的字段构建索引，可以直接在叶子节点查到所有字段，避免了查询再次检索主键索引，避免回表

#### 主键索引自增
- 使用自增的主键，在每次插入新数据的时候避免了频繁在中间位置插入，导致节点分裂
- 主键字段的长度不要太大，因为二级索引的叶子节点存放的是主键值

#### 防止索引失效
常见的索引失效情况：
- 当使用左或者右右模糊匹配时，也就是 `like %xx` 或者 `like %xx%`这两种方式都会造成索引失效；
- 当在查询条件中对索引列做了计算、函数、类型转换操作时
- 联合索引未遵循最左匹配原则
- 在WHERE子句中，如果在OR前的条件列是索引列，而在OR后的条件列不是索引列，那么索引失效