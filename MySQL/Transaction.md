## 事务
### 事务的隔离级别是怎么实现的？
#### 事务的特性
- 原子性(Atomicity)：事务的所有操作，要么都完成，要么都不完成
- 一致性(Consistency)：数据满足完整性约束，事务操作前后数据据库状态的一致性
- 隔离性(Isolation)：多个并发事务之间是隔离的，每个事务都有一个完整的数据空间
- 持久性(Durability)：事务结束后，对数据的修改是永久的，即使系统发生故障或断电

#### 并发事务可能引发的问题
- 脏读：如果一个事务读到了另一个**未提交事务修改过的数据**, 就意味着发生了脏读
- 不可重复读：在一个事务内多次读取同一个数据，出现前后两次读到的数据不一样的情况
- 幻读：在一个事务内多次查询某一条件下的数据，出现前后两次读到的记录数量不一致的情况、

#### 事务的隔离级别
- 读未提交：指一个事务还没提交时，它做的变更就能被其他事务看到
- 读已提交：指一个事务提交之后，它做的变更才能被其他事务看到
- 可重复读：指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的
- 串行化：会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行

如何实现这四种隔离级别？
- 读未提交：因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了
- 对于【读提交】和【可重复读】来说，它们是通过** Read View 来实现的，它们的区别在于创建Read View 的时机不同，大家可以把 Read View 理解成一个数据快照。
  【读提交】隔离级别是在每一个语句执行前都会重新生成一个 Read View， 而【可重复读】隔离级别是【启动事务时】生成一个 Read View， 然后整个事务期间都在用这个
  Read View。
- InooDB引擎对于【可重复读】隔离级别很大程度上解决**幻读**的方案：
  - 针对快照读（普通select语句），通过MVCC方式解决了幻读
  - 针对当前读（select ... for update)，**通过【next-key lock】方式解决了幻读**，在执行语句时加上next-key lock锁，其他事务在这个范围内插入或删除语句时会被阻塞
    所以很好地避免了幻读问题
- 串行化：通过加读写锁的方式来避免并行访问
#### Read View在MVCC里如何工作的？

![img.png](D:\project\JavaLearingNotes\MySQL\imgs\img.png)

- 如果记录中的trx_id值小于Read View中的min_trx_id值，表示这个版本的记录是在创建视图**前**已经提交的事务生成的，所以该版本的记录对当前事务**可见**
- 如果记录中的trx_id大于等于Read View中的max_trx_id值，表示这个版本的记录是在创建视图**后**才启动的事务生成的，所以该版本的记录对当前事务**不可见**
- 如果记录的trx_id值在Read View的min_trx_id和max_trx_id之间，需要判断trx_id是否在m_ids列表中：
  - 如果存在，表示生成该版本记录的活跃事务仍然活跃着（未提交），所以该版本的记录对当前事务不可见
  - 如果不存在，表示生成该版本记录的事务已经被提交，所以该版本的记录对当前事务可见