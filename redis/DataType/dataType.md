## String
- 内部实现
  - String 类型的底层数据结构是int和SDS（简单动态字符串）
    - SDS内部都是用处理二进制的方式处理数据，所以不仅可以保存文本，还可以保存图片，视频等
    - SDS用Len属性记录数据长度
  - 字符串对象的内部编码方式有三种：int , raw, embstr
    - embstr针对长度小于32字节的短字符串，redisObject和SDS为一块连续空间
    - raw针对长字符串，redisObject和SDS空间不连续，为额外创建一块空间来保存SDS
    - int，直接把整数值存在redisObject对象的ptr字段中

## List
- 底层实现
  - List数据类型为 quickList
- 应用场景
  - 消息队列
    - redis提供BRPOP阻塞式读取，客户端在没有读到队列数据时，自动阻塞，直到有新的数据写入队列，再开始读取新数据。  
    （就不需要消费者不断轮询队列是否有数据
    - 如何处理重复的消息？
      - 为每个消息生成一个全局id
      - List并不会自动帮消息生成id，我们需要自行为消息生成全局id，在LPUSH时就可以指定id
    - 如何保证消息可靠性
      - 如果消费者把消息读出去以后自己出现宕机或故障，消息就丢失了（使用BRPOPLPUSH，让消费者在从一个list读取消息时，  
      同时redis会把这个消息再插入到另一个list作为备份
    - 缺陷：不支持多个消费者消费同一条消息，不支持消费组的实现

## hash
- 底层实现
  - redis7.0以后 listpack数据结构
- 应用场景
  - 缓存对象
    - Hash类型的 (key, field, value) 与对象的结构相似，一般可用来保存对象
    - ![img.png](..%2Fimgs%2Fimg.png)

## set
- 底层实现
  - 哈希表或者整数集合
    - 如果集合中的元素都是整数且元素个数小于512，则用整数集合
    - 否则用哈希表
- 应用场景
  - 点赞
    - 用集合记录对某个特定视频点赞的用户id
  - 共同关注
    - Set类型支持交集运算
  - 抽奖活动

## zset
相比于set类型多了一个排序属性score
![img_1.png](..%2Fimgs%2Fimg_1.png)
- 底层实现
  - 压缩列表：如果有序集合的元素个数小于128个，并且每个元素的值小于64字节 （redis7.0以后使用 listpack)
  - 跳表
- 应用场景
  - 排行榜
  - 姓名 电话号码排序 （使用ZRANGEBYLEX命令，eg ZRANGEBYLEX phone [132 (133 

## bitmap
- 底层实现
  - bitmap本身是用string类型作为底层数据结构实现的
  - string类型是会保存为二进制的字节数组，所以，redis就把字节数组的每个bit位利用起来，用来表示一个元素的二值状态，可以把bitmap当成一个Bit数组

## stream
- 更好地支持消息队列
  - 消息自动生成全局唯一id
  - 支持消费组模式，不同消费组如果从相同位置读取消息，可以消费到同一条消息
  - 支持消费者发送ack确认消息，对于暂未确认的消息仍然会留存，消费者如果中途故障，可以用XPENDING查看未确认的消息
  - 不足之处：
    - 数据丢失
      - redis aof持久化异步写盘过程时，redis宕机存在数据丢失的情况
      - 主从复制也是异步，主从切换时，也存在丢数据的可能
    - 消息不可堆积
      - redis的数据都存在内存里，redis的消息不能无限堆积，当达到最大长度时存在丢失问题