## 缓存
### 缓存雪崩
- 可能的原因
  - 大量数据同时过期  
    解决办法
      - 均匀设置过期时间，避免大量key同时过期
      - 互斥锁：当业务线程发现数据不在redis中，就加一个互斥锁，避免大量线程同时前往数据库查询数据
      - 后台更新缓存：让缓存永久有效，将更新缓存的任务交给后台线程定时更新
        - 业务线程发现缓存失效后，通过消息队列发送一条消息通知后台更新缓存，后台线程收到消息后，判断缓存是否存在，如果
        不存在则从数据库读取数据更新缓存
  - redis宕机  
    解决办法
    - 服务熔断或接口限流
      - 服务熔断：暂停业务应用对缓存服务的访问，直接返回错误，待redis恢复，这种方式阻断了所有业务应用访问缓存服务
      - 接口限流：只将少部分请求发送到数据库进行处理，再多的请求就在入口直接拒绝服务，等到redis恢复正常并完成缓存预热
    - 构建redis缓存高可靠集群
      - 利用主从节点方式构建可靠集群

### 缓存击穿
如果缓存中的某个热点数据过期了，此时大量的请求访问了该热点数据，就无法从缓存中读取，直接访问数据库，数据库就容易被高并发的请求冲垮，这就是缓存击穿的问题  
可以认为缓存击穿是缓存雪崩的一个子集

### 缓存穿透
当用户访问的数据，既不在缓存中，也不在数据库中，导致无法建立相关缓存，来服务后续的请求。  
那么当大量这样的请求到来时，数据库的压力剧增，这就是缓存穿透的问题。
- 非法请求的限制
  - 在api入口，判断请求参数合理性，是否含有非法值等
- 缓存空值或默认值
  - 针对从数据库读不到的数据设置默认返回值或直接返回空值

### 数据库和缓存如何保证一致性

![img.png](imgs%2Fimg.png)
- 先删除缓存再更新数据库 （可以利用延迟双删的操作，解决一致性问题）  
在请求A更新完数据库后，sleep(1s)左右再删除一次缓存，可以较好地解决请求B把脏数据写进了缓存的情况
![img_1.png](imgs%2Fimg_1.png)
- 先更新数据库，再删除缓存 （ 更新数据库的时间要远远大于大于更新缓存的时间，这种情况下发生不一致性的概率比较小

但是删除缓存的操作有可能失败，这种情况会导致缓存与数据库的数据不一致，如何保证删除缓存的操作呢？
- **异步**操作缓存
  - 利用消息队列保存要删除缓存的消息
  - 订阅binlog，利用缓存服务删除缓存