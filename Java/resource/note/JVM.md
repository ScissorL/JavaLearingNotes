### 内存区域



### 垃圾回收算法
#### G1
- G1与CMS的不同：
  - G1是compacting的，因此其回收得到的内存空间是连续的。  
  连续空间意味着G1垃圾回收器可以不必采用空闲链表的内存分配方式，而可以直接采用bump-the-pointer的方式（跟踪在eden区保存的最后一个对象，这个对象一般是在栈顶，所以很快地判断这个对象后面是否还有足够空间）
  - G1回收器的内存与CMS内存模型有较大不同：G1将内存划分一个个固定大小的region，每个region可以是年轻代、老年代中的一个。内存的回收是以region为基本单位的
  - 软实时：用户可以指定垃圾回收的限时，G1会努力在这个时限内完成垃圾回收，但是并不担保每次都在这个时限内完成。通过设定一个合理的目标，可以让达到90%以上的垃圾回收时间都在这个时限内。
- G1的内存分代模型  
  ![img_2.png](..%2Fimgs%2Fimg_2.png)
  - 本地分配缓冲，每个应用线程和GC线程都可以独立的使用分区，减少同步时间，提升GC效率。
  - G1将内存划分为一个一个固定大小的region, 一个大小大于等于region一半的对象称为巨型对象。巨型对象会直接在老年代分配。但是G1做了一个优化，巨型对象可以在年轻代回收周期内被回收
  - RSet：用于记录引用本分区内对象的卡片索引，当要回收该分区时，通过扫描分区的RSet，来确定引用本分区内的对象是否存活，进而确定本分区内对象的存活请款
  - 收集集合Cset  
  ![img_3.png](..%2Fimgs%2Fimg_3.png)
    - 年轻代收集集合：当JVM分配对象到Eden区域失败时，会触发一次STW式的年轻代收集。在年轻代收集中，Eden区存活的对象会被拷贝到Survivor分区；  
    原有的Survivor分区存活对象，将根据任期阈值分别晋升到PLAB中，新的Survivor分区和老年代分区。而原有的年轻代分区将被整体回收掉。
    - 混合收集集合：当年轻代收集不断活动，老年代的空间也会被逐渐填充。当老年代占用空间超过一定阈值，G1就会启动一次混合垃圾收集周期。  
    为了满足暂停目标，一般会启动连续多次的混合垃圾回收周期，和应用线程之间交替执行。
    - 并发标记算法：三色标记法  
    ![img_4.png](..%2Fimgs%2Fimg_4.png)  
    GC 开始前所有对象都是白色，GC 一开始所有根能够直达的对象被压到栈中，待搜索，此时颜色是灰色。然后灰色对象依次从栈中取出搜索子对象，子对象也会被涂为灰色，入栈。当其所有的子对象都涂为灰色之后该对象被涂为黑色。当 GC 结束之后灰色对象将全部没了，剩下黑色的为存活对象，白色的为垃圾。
- G1的活动周期
  - G1垃圾收集活动汇总  
  ![img_5.png](..%2Fimgs%2Fimg_5.png)  
  - Rset的维护  
  栅栏代码示意：  
  ![img_6.png](..%2Fimgs%2Fimg_6.png)
    - 栅栏barrier
      - 写前栅栏：执行赋值语句前，等式左侧原先引用的对象所在分区将会因此丧失一个引用，那么JVM就需要在语句生效前，记录丧失引用的对象。JVM不会立即更新Rset，而是在将来批量处理，更新Rset
      - 写后栅栏：执行赋值语句后，等式左侧对象获取了等式右侧对象的引用，那么等式右侧对象所在分区的RSet也应该更新，同样也是记录更新日志，在将来批量处理
   